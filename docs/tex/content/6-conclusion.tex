\chapter{Conclusion}
\label{ch:conclusion}

In this work, a network-based cinema management system was successfully developed, fulfilling all previously outlined requirements. These requirements were initially identified through use cases in \cref{sec:use-cases} and subsequently translated into a data model in \cref{sec:cs-data-model}. Following slight adjustments to the data model due to technical limitations detailed in \cref{sec:cs-data-mps}, automated code generation with \gls{a:mps} was employed to generate the data access layer in Java. With the addition of the isolation service in \cref{sec:cs-isolation}, the generated code played a vital role in the successful implementation of the management system, facilitating controlled network communication between the client and server.

\section{Evaluation}
The \gls{g:cms} prototype was developed using the latest .NET 7 \gls{a:sdk} and C\# 11 for the client, ensuring cross-platform compatibility by testing on Windows 10, Debian GNU/Linux 12, and macOS 12.3.1. The client successfully communicated with the remote \gls{g:cms} Java 17 server, enabling users on any platform to register and manage their accounts, reserve and book tickets for available movie screenings, or cancel previously retained reservations as necessary. The management interface proved invaluable, as cinema owners could effortlessly add new movies to the system, schedule additional movie screenings, or manage their physical cinema infrastructure such as rooms, seats, or seat rows.

Despite some challenges, development of the Java-powered backend progressed swiftly, as the data access layer was primarily automatically generated by \gls{a:mps} based on the previously defined data model. By leveraging Model Driven Development techniques to shorten the required development time of the server, the team could focus on providing an intuitive and user-friendly client application featuring tab-command completion, syntax highlighting, and extensive help information. Minor inconveniences arose from the data access layer, as database transactions were not natively supported by the generated code. A custom isolation layer was implemented, mitigating the risk of conflicts through concurrent user activity while promoting serializable data access.

Although the \gls{g:cms} prototype demonstrated a reliable and viable software solution for cinema management, additional work is required before deploying it to production.


\section{Future Development Prospects}
\label{sec:outlook}

Although all requirements have been satisfied and the final implementation functions as intended, there remain several areas that could benefit from additional development. In the subsequent subsections, we briefly outline these areas and their associated tasks for future improvement.

\subsection{Persisting PriceCategory in the Database}

\Cref{sec:impl-challenges-price} discusses a bug where setting the \inlinecode{price} property of the \inlinecode{PriceCategory} singletons in the database upon service startup would fail consistently. Due to the limited time frame allotted for the development process, this problem remained unresolved. The root cause and potential solutions have yet to be identified. The next step involves further investigation of the issue before devising and implementing an appropriate solution.

\subsection{Generating RRMs from MPS data models}

As stated at the end of \cref{sec:cs-api-endpoints}, \gls{a:mps} data models are incompatible with the \gls{a:json}-based \glsfull{a:rrm}, which resulted in additional development time required for each implemented \gls{a:api} endpoint. To save time and eliminate the need for manual creation of multiple classes per data model, research on the automatic generation of such classes should be conducted and eventually implemented.

\subsection{Priority heap structure instead of FIFO Queue}

The isolation service currently employs a regular \gls{a:fifo} queue for scheduling upcoming data accesses, as described in \cref{sec:cs-isolation}. This scheduling mechanism does not allow for prioritization of actions, treating all tasks equally even when \inlinecode{admin} and \inlinecode{management} tasks should arguably take precedence. Replacing the queue with a priority heap structure should be explored.

\subsection{Extending the code generator to use transactions}

As elaborated in \cref{subsec:missing-transactions}, the absence of transactional data access significantly hindered the development process, leaving inconsistent database states after each server crash and making production deployment unfeasible. This issue is of the highest importance and should take priority over the other aforementioned concerns. The \gls{a:mps} project must be adjusted to support transactions.

\section{Final thoughts}

Throughout the design and development of the \gls{g:cms} prototype, we encountered various challenges, including technical issues and coordination difficulties. As we progressed through the project's different stages, effective communication and collaboration among team members proved crucial for maintaining alignment and fostering progress.

Initially, code generation was perceived as a valuable tool, offering substantial advantages in terms of speed and efficiency. However, we discovered that its benefits were not as pronounced as anticipated. Although it reduced the amount of manual coding efforts, we kept encountering problems that demanded attention, and a significant amount of time was spent troubleshooting and debugging generated code.

Despite these challenges, our team successfully designed and implemented a \gls{g:cms} prototype that met the project specifications. We also gained valuable insights into the importance of teamwork and communication, as well as the limitations and advantages of code generation in real-world software development projects.