\chapter{Theoretical Foundation}
\label{ch:foundation}

This chapter provides a theoretical foundation for this work and introduces the reader to the concepts of code generation, the \gls{g:spring} \gls{a:api}, and the .NET platform. It will serve as a basis for the conceptual design and implementation of the proposed cinema management framework as well as for the evaluation presented thereafter.

\section{Code Generation}
\sectionauthor{Jana Schlüsche}

Code generation plays a significant role in software development by enhancing developer productivity. As a crucial component of \gls{a:mdd}, a software development approach that utilizes models as primary development artifacts, code generation contributes to the overall efficiency and effectiveness of the development process. Compared to conventional software development approaches, \gls{a:mdd} provides a higher level of abstraction and improves code reusability \cite{voelter2017model}. In this context, code generation refers to the process of automatically producing source code or machine code from a higher-level abstract description or model, streamlining the development process and reducing manual implementation efforts. This process usually involves a specific language and platform defined by developers \cite{greenfield2002code}.

Various tools are available for code generation, including \glspl{a:ide}, code generators and templates. Of these, the \glsfull{a:mps} by JetBrains will be discussed in further details due to its relevance for this work \cite{biermann2017model}.

\subsection{MPS}

The \glsfull{a:mps} is an \gls{a:ide} and software development platform developed by JetBrains. By using \gls{a:mps}, software developers can automatically generate source code targeting a variety of languages. It is a \gls{a:mdd} tool operating on the principle that the developer designs a model of their proposed system and generates corresponding source code based on this model. This offers developers an immense simplification, enabling them to focus on modeling and defining the requirements for the application instead of manually writing code. Consequently, this reduces the amount of manual work that is traditionally involved in the development of applications, decreasing the likelihood of errors. In addition, the generated source files can be automatically imported into existing projects, which further accelerates the development process. Overall, \gls{a:mps} assists the developers to work quicker and more efficiently allowing them to focus on the development of core functionalities \cite{voelter2013study}.


\section{RESTful APIs}
\sectionauthor{Ben Bekir Ertugrul}

\todo{@Ben}

\subsection{Spring Boot}

\todo{@Ben}

\section{An Antroduction to .NET}\label{sec:tf-dotnet}
\sectionauthor{Frederik Höft}

.NET is a platform designed for the development and execution of applications within a managed virtual machine called the \gls{a:cclr}, ensuring platform and hardware independence. To facilitate the execution of a single .NET application on multiple platforms, the source code is first compiled into byte code, commonly known as \gls{a:il}. This \gls{a:il} byte code can then be distributed and executed on any platform that has a .NET runtime available. When executed, the \gls{a:il} byte code is compiled into architecture-specific instructions through a process called \gls{a:jit}-compilation.

Starting from .NET Core 3.1, .NET applications can be published as self-contained executables, meaning that the entire application, including the \gls{a:cclr}, is packaged and distributed as a single file. This allows for the execution of the application without requiring a system-wide \gls{a:cclr} installation.

The most recent .NET 7 release introduced \gls{a:aot} compilation, enabling applications with all their dependencies to be directly compiled into native machine code targeting the different processor architectures. This offers a significant performance improvement compared to previous .NET versions, as no \gls{a:jit} compilation is necessary during execution.

\subsection{System.CommandLine framework}

\inlinecode{System.CommandLine} is an open-source .NET library, currently in preview, that provides a framework for building \gls{a:cli} applications. Designed to be highly extensible, it allows for the creation of complex console applications using custom commands, arguments, options, and modifiers. It provides a simple and intuitive programming interface, and offers a variety of features, including argument validation, parameter binding, and help information generation.

Commands and sub-commands can easily be defined as a tree-like data structure, offering a high level of flexibility. The arguments are parsed and validated automatically, greatly simplifying the implementation of the \gls{a:cli}. Additionally, the library provides a set of default commands, such as \inlinecode{help} and \inlinecode{version}, which can be used to generically display help information or the application's version. 

An example of a simple console application implemented with \inlinecode{System.CommandLine} is shown in \Cref{lst:cli-example}.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{csharp}
RootCommand rootCommand = new("Will print a greeting to the console.")
{
    new Argument<string>("name", "The name of the person to greet."),
    new Option<int>("--age", () => 30, "The age of the person to greet."),
    new Option<bool>("--formal", () => false, "Whether to use a formal greeting.")
};

rootCommand.Handler = CommandHandler.Create<string, int, bool>((name, age, formal) =>
{
    string greeting = formal ? "Hello, Mr./Ms. " : "Hi, ";
    Console.WriteLine($"{greeting}{name}! You're {age} years old.");
});

return rootCommand.Invoke(args);
\end{minted}
\caption{An example of a simple \gls{a:cli} application using the \inlinecode{System.CommandLine} framework.}
\label{lst:cli-example}
\end{listing}

As illustrated in \Cref{lst:cli-example}, a \inlinecode{RootCommand} can be defined to represents the root of the parameter tree, serving as an entry point to the framework. It can contain multiple position-independent \inlinecode{Argument} or \inlinecode{Option} objects. Nested \inlinecode{Command} objects with additional handlers to represent various sub-commands of the root command are also possible. These objects can parse and validate the \gls{a:cli} arguments and options, which can then be easily bound to objects and passed to a handler function executed when the command is invoked.

Utilizing \inlinecode{System.CommandLine} offers the benefit of streamlining command-line parsing with just a few lines of code, which facilitates quicker development cycles and reduces the amount of code requiring maintenance.

