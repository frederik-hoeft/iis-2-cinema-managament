% \title{Designing a Network-based Cinema Management Solution using Code Generation}

\chapter{Abstract}

\todo{first draft:}
As digitalization progresses, more and more industries require software solutions that can be adapted to their specific needs. In the area of cinema management, such an approach is necessary, as the individual cinemas vary greatly in their size, equipment, and business model. The goal of this work is to develop a network-based solution for managing core cinema infrastructure, such as cinema halls, movie showtimes, and ticket sales. 

\vspace{.1cm}
\hspace{-.6cm}In order to achieve this goal, concrete use cases are analyzed and drafted into a requirements specification. Based on these requirements, a conceptual design is created, which includes a client-server architecture and a data model. The conceptual design is then implemented in Java prototype, leveraging MPS as a modeling language for the data model and Spring Boot for the API. A C\# Client is developed as a proof of concept, which communicates with the server, and a command line interface is created for user interaction.

\vspace{.1cm}
\hspace{-.6cm}Although the prototype meets the requirements, it is not production-ready, as it lacks a user interface, authentication, and error handling. Further work is required to create a fully functional application that can be used in a real-world scenario.

\chapter{Introduction}
\label{ch:intro}

This applied research project was conducted as part of an assignment for the course \enquote{Informationsinfrastrukturen 2} at \gls{a:fhdw} Hannover, supervised by Prof. Dr. Harald KÃ¶nig.

\section{Objectives of this work}

\todo{generic introduction to the problem + what we're even doing here}

\todo{this is a first draft:}
The goal of this work is to develop a network-based solution for managing core cinema infrastructure, such as cinema halls, movie showtimes, and ticket sales. The solution should be generic and easily adaptable to the individual needs of each cinema. In order to achieve this goal, the following objectives are defined:

\begin{itemize}
    \item Develop a conceptual design for a generic cinema management solution.
    \item Implement a prototype of the solution, which can be used as a proof of concept.
    \item Evaluate the solution and identify areas for improvement.
\end{itemize}

\section{About \glslongtext{a:cms}}

% use acronym version once here!
\gls{a:cms}

\todo{because it's nice to give a name to whatever we're doing here... cause \inlinecode{\gls{the-thing}} is easy}

The cinema thing is currently simply called \gls{g:cms}. Change it if you want.

\section{Structure of this work}

Five additional chapters follow this introduction. \Cref{ch:foundation} establishes a theoretical foundation for the subsequent chapters by providing an introduction to \gls{a:mps} code generation, the Spring Boot \gls{a:api}, and the .NET platform. \Cref{ch:problem-analysis} investigates the different use-cases associated with cinema management, ticket sales, and administration, analyzing potential pitfalls and deriving concrete requirements for the solution. \Cref{ch:concept} presents a conceptual solution to address these issues. This solution is then implemented and evaluated in \cref{ch:impl}. Finally, \cref{ch:conclusion} evaluates and discusses the results of this work, the current state of the project, and potential avenues for future development.

\chapter{Theoretical Foundation}
\label{ch:foundation}

This chapter provides a theoretical foundation for this work and introduces the reader to the concepts of code generation, the \gls{g:spring} \gls{a:api}, and the .NET platform. It will serve as a basis for the conceptual design and implementation of the proposed cinema management framework as well as for the evaluation presented thereafter.

\section{Code Generation}

Code generation plays a significant role in software development by enhancing developer productivity. As a crucial component of \gls{a:mdd}, a software development approach that utilizes models as primary development artifacts, code generation contributes to the overall efficiency and effectiveness of the development process. Compared to conventional software development approaches, \gls{a:mdd} provides a higher level of abstraction and improves code reusability \cite{voelter2017model}. In this context, code generation refers to the process of automatically producing source code or machine code from a higher-level abstract description or model, streamlining the development process and reducing manual implementation efforts. This process usually involves a specific language and platform defined by developers \cite{greenfield2002code}.

Various tools are available for code generation, including \glspl{a:ide}, code generators and templates. Of these, the \glsfull{a:mps} by JetBrains will be discussed in further details due to its relevance for this work \cite{biermann2017model}.

\subsection{MPS}

The \glsfull{a:mps} is an \gls{a:ide} and software development platform developed by JetBrains. By using \gls{a:mps}, software developers can automatically generate source code targeting a variety of languages. It is a \gls{a:mdd} tool operating on the principle that the developer designs a model of their proposed system and generates corresponding source code based on this model. This offers developers an immense simplification, enabling them to focus on modeling and defining the requirements for the application instead of manually writing code. Consequently, this reduces the amount of manual work that is traditionally involved in the development of applications, decreasing the likelihood of errors. In addition, the generated source files can be automatically imported into existing projects, which further accelerates the development process. Overall, \gls{a:mps} assists the developers to work quicker and more efficiently allowing them to focus on the development of core functionalities \cite{voelter2013study}.

\section{RESTful APIs}

\todo{@Ben}

\subsection{Spring Boot}

\todo{@Ben}

\section{An Antroduction to .NET}

.NET is a platform that enables the development and execution of applications in a managed virtual machine referred to as the .NET Core Common Language Runtime (CoreCLR), thereby ensuring platform and hardware independence. To enable the execution of a single .NET application on multiple platforms, the source code is initially compiled into byte code, typically referred to as \gls{a:il}. This \gls{a:il} byte code can then be distributed and executed on any platform with a .NET runtime available. Upon execution, \gls{a:il} byte code is compiled into architecture-specific instructions in a process known as \gls{a:jit}-compilation

Ever since .NET Core 3.1, .NET applications can be published as a self-contained executable, which means that the entire application, including the .NET Core runtime, is packaged and distributed as a single file. This allows for the execution of the application without the need for a .NET Core runtime installation.

With the introduction of ahead-of-time (AOT) compilation in the most recent .NET 7 release, the application and all of its dependencies can be directly compiled into native machine code targeting x86, x86_64, ARM, and ARM64 architectures. This allows for a significant performance improvement compared to the previous .NET versions as no just-in-time compilation is required during execution.

\subsection{System.CommandLine framework}

\inlinecode{System.CommandLine} is an in-preview .NET library that provides a framework for building command-line interfaces. It is designed to be highly extensible, allowing for the creation of complex command-line interfaces with the help of custom command-line commands, arguments, options, and modifiers. It provides a simple and intuitive programming interface and offers a variety of features, including command-line argument validation, parameter binding, help information generation, and argument completion.

Commands and sub-commands can easily be defined as a tree-like data structure, which provides a high level of flexibility in the design of the command-line interface. The command-line arguments can be parsed and validated automatically, which greatly simplifies the implementation of the command-line interface. In addition, the library provides a set of default commands, such as \inlinecode{help} and \inlinecode{version}, which can be used to generically display help information or the version of the application. Arguments can be bound to objects and passed to a handler function, which is executed when the command is invoked.

An example of a simple command-line interface that can be implemented with \inlinecode{System.CommandLine} is shown in \Cref{lst:cli-example}.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{csharp}
RootCommand rootCommand = new("Will print a greeting to the console.")
{
    new Argument<string>("name", "The name of the person to greet."),
    new Option<int>("--age", () => 30, "The age of the person to greet."),
    new Option<bool>("--formal", () => false, "Whether to use a formal greeting.")
};

rootCommand.Handler = CommandHandler.Create<string, int, bool>((name, age, formal) =>
{
    string greeting = formal ? "Hello, Mr./Ms. " : "Hi, ";
    Console.WriteLine($"{greeting}{name}! You're {age} years old.");
});

return rootCommand.Invoke(args);
\end{minted}
\caption{An example of a simple command-line interface using the System.CommandLine framework.}
\label{lst:cli-example}
\end{listing}

\Cref{lst:cli-example} shows the usage of \inlinecode{System.CommandLine} to create a simple command-line interface. The \inlinecode{RootCommand} represents the root command of the command-line interface and is used as an entry point to the framework. It can contain multiple position-independent \inlinecode{Argument}, or \inlinecode{Option} objects. Nested \inlinecode{Command} objects with additional handlers to represent various sub-commands of the root command are also possible. These objects can be used to parse and validate the command-line arguments and options, which can then easily be bound to objects and passed to a handler function, which is executed when the command is invoked.

An automatic help command is provided by the framework by default. This command can be invoked by passing the \inlinecode{--help} or \inlinecode{-h} flag to the application. The framework will then automatically generate and display help information, including the description of the root command, a list of all possible commands, a description of all command-line arguments and options, and the default values for these options. 

The advantage of using \inlinecode{System.CommandLine} is that the entire command-line interface can be defined with a few lines of code, allowing for faster development cycles and less code that needs to be maintained.

\chapter{Problem analysis and requirements}
\label{ch:problem-analysis}

This chapter investigates the different use cases associated with cinema management and discusses potential pitfalls in the design of a generic solution. To gain a comprehensive understanding of the problem space, detailed use cases are analyzed and requirements are derived therefrom. A list of requirements is presented, which will serve as a basis for the conceptual design in the following chapter.

\section{Use cases}\label{sec:use-cases}

\todo{use-case diagram + detailed description}

An application use case diagram was created with the incoming task, which visually represents both the essential points of communication between the user and the website, as well as the configuration and use of the cinema owner and can be understood by all parties involved. The visual representation of the situation is intended to ensure that communication between all parties runs smoothly and requirements can be derived from it.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/iis-use.case-new.pdf}
    \caption{Use-case diagram of reservation/ticket purchase}
    \label{fig:use-cases}
\end{figure}

\todo{hier detailierte beschreibung}

\pagebreak

\section{Requirements}
\label{sec:requirements}

The investigation of the challenges elucidated in the use cases and the constraints associated therewith have led to the establishment of the following prerequisites for the proposed \gls{g:cms} solution. These requirements will serve as a basis for the conceptual design in the following chapter.

\todo{this is by no means complete :P}

\renewcommand{\arraystretch}{1.25}
\begin{table}[H]
    \centering
    \caption{Summary of requirements for \gls{g:cms}.}
    \label{tab:requirements}
    \begin{tabular}{l|p{0.75\textwidth}}
        \toprule
        Requirement & Description \\ \midrule
        \requirementdefshort\label{req:use-cases}  & \gls{g:cms} must cover the use-cases discussed in \cref{sec:use-cases}. \\ \hline
        \requirementdefshort\label{req:model-requirements}  & \gls{g:cms} must comply with all model-specific requirements specified in \cref{apx:ch:extended-analysis}. \\ \hline
        \requirementdefshort\label{req:client-server} & \gls{g:cms} must utilize the client-server architecture, allowing multiple concurrent clients to access its services. \\ \hline
        \requirementdefshort\label{req:database} & A database engine must be used to persist cinema data. \\ \hline
        \requirementdefshort\label{req:server} & The \gls{g:cms} server must be written in as a Java application complying with the principles of model driven development. \\ \hline
        \requirementdefshort\label{req:mps} & \gls{a:mps} by JetBrains must be used to generate the Java source code for data access layer and the SQL DDL required for the database schema \cite[1]{IIS2-ass}. \\ \hline
        \requirementdefshort\label{req:mysql} & \gls{g:cms} data must be persisted in a MySQL database. \\ \hline
        \requirementdefshort\label{req:isolation} & Database access must be performed in a thread-safe and isolated manner. \\ \hline
        \requirementdefshort\label{req:api} & The server must provide a \gls{a:rest}ful \gls{a:json} \gls{a:api} for the client application to communicate with, as established in \todo{use-case here}. \\ \hline
        \requirementdefshort\label{req:client-access} & The client application must be able to connect to the server via a \gls{a:rest}ful \gls{a:json} \gls{a:api}. \\ \hline
        \requirementdefshort\label{req:client-cli} & A \gls{a:cli} must be provided for user interaction within the client application. \\ \hline
        \requirementdefshort\label{req:client-portability} & The client application must be capable of being published as a self-contained executable, guaranteeing portability without reliance on any additional runtime environment for installation. \\ 
        \bottomrule
    \end{tabular}
\end{table}
\renewcommand{\arraystretch}{1}

\chapter{Conceptual solution}
\label{ch:concept}

This chapter introduces the proposed conceptual solution, which forms the basis for the implementation discussed in \cref{ch:impl}. Initially, an overview of the project structure is provided. Subsequently, the server-side infrastructure is examined, assessing the most suitable data model for use with \gls{a:mps} code generation, emphasizing key components, and ensuring thread-safe interactions among them. Finally, the client application is explored in depth, addressing its architecture, design, and quality of life enhancements.

\section{Project Infrastructure}

This section introduces the architectural solution designed to meet the requirements delineated in \cref{sec:requirements}. The comprehensive project architecture is illustrated in \cref{fig:architecture}, which encompasses three primary components: the client application, the server-side infrastructure, and the database.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/big-picture-no-lombok}
    \caption{Key aspects encompassing project architecture of the proposed solution.}
    \label{fig:architecture}
\end{figure}

\Cref{fig:architecture} illustrates the project architecture for the proposed solution. The architecture allows for multiple client application instances to connect concurrently to a single server instance, facilitating simultaneous user interactions. Communication between the client and server is achieved through a \gls{a:rest}ful \gls{a:json} \gls{a:api}, which adheres to standardized conventions and promotes interoperability between the C\# clients and the Java server. The design of the client is elaborated in further details in \cref{sec:cs-client}.

Upon invoking a specific endpoint using the client application, the server-side \gls{g:spring} \gls{a:api} controllers handle deserialization of the corresponding \gls{a:json} request model in accordance to the \gls{a:api} design specified in \cref{sec:cs-api}. These \gls{a:api} controllers subsequently process the request utilizing \gls{a:mps}-generated data access layer elucidated in \cref{sec:cs-data-model}, therefore ensuring a consistent, efficient, and maintainable interface with the underlying data storage.

The \inlinecode{IsolationService} plays a crucial role in managing and scheduling the data access requests performed by the \gls{a:api} controllers. It provides a level of isolation between concurrent requests, ensuring data consistency and preventing conflicts or race conditions. This service facilitates communication with the \gls{a:mps}-generated database schema, which is tailored to efficiently store and manage the system's data. A more comprehensive overview of the isolation service is provided in \cref{sec:cs-isolation}.

\section{Server}

The server application constitutes the central component of the \gls{g:cms}, overseeing the data model management and furnishing a \gls{a:rest} \gls{a:api} for client interactions. The implementation of the data model harnesses the \gls{a:mps} framework, while the \gls{a:rest} \gls{a:api} employs the \gls{g:spring} framework. Developed using Java, the server application capitalizes on the Maven build system. Ensuing sections provide a thorough analysis of the server application's architecture, commencing with an overview of the data model derived from the use-cases delineated in \cref{sec:use-cases}, continuing with an exposition of the \gls{a:rest} \gls{a:api}, and concluding with the presentation of the isolation layer.

\subsection{Data Model Design}\label{sec:cs-data-model}
The data model was created according to the requirements presented in chapter \ref{ch:problem-analysis}, see figure \ref{fig:data-model}. In order to provide a better orientation, the description of this figure should be from left to right.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/data-model-final.pdf}
    \caption{Data model for CMS according to requirements.}
    \label{fig:data-model}
\end{figure}

The class Movie contains two items, on the one hand a title as a string and on the other hand a description also as a string. The MoveScreening class contains two attributes according to the requirements. The attribute finished as a Boolean, indicates whether the film has finished screening and the attribute name as a string, identifies the name of each film screening. Between the classes Movie and MovieScreening there is an association as Containment. Furthermore, the CinemaHall class is required. It only has one attribute, namely whether the hall is currently in use. There is an association as containment within the CinemaHall and MovieScreening classes. Next, a class called SeatRow and another class Seat are necessary. The CinemaHall class and the SeatRow class have an association as a containment. There should also be a containment association from SeatRow to Seat. In addition, an abstract class BoookingState is needed for the booking system. This class is specified by the classes Reservation and Booking. There is again a containment association from the class to Seat to the abstract class BookingState. MovieScreening has a second association to BookingState, this one is also a containment. 
% you can use \inlinecode{MyClass} for code :)

\subsubsection{Compliance with MPS}

\todo{add subsubsections as needed!}

\todo{The UML diagram + formally proof containments for *all* relationships, e.g., A Seat Row cannot exist without a Cinama Hall and ...}

\todo{How do we need to change the model to comply with MPS? (Hint: enums and singletons)}

\pagebreak

\subsection{REST API}\label{sec:cs-api}

The \gls{a:rest} \gls{a:api} offers the client application an interface for interacting with the server. It comprises a set of \gls{a:rest}ful \gls{a:json} \gls{a:api} endpoints, with each endpoint handling a specific task.

\subsubsection{Endpoint Design}\label{sec:cs-api-endpoints}

To achieve a consistent and intuitive \gls{a:api} design, the endpoints were developed based on the use-cases outlined in \cref{sec:use-cases}. Consequently, the endpoints are initially grouped by the role responsible for performing the action, followed by the target of the action, and finally by the action itself. \Cref{fig:api-tree} illustrates a portion of the resulting tree structure of the \gls{a:api} endpoints, which is subsequently employed to create the Java \gls{g:spring} controllers.

\begin{figure}[H]
\renewcommand*\DTbaselineskip{10pt}
{\scriptsize
\dirtree{%
.1 \apiexpanded \ /.
.2 \apiexpanded management/. 
.3 \apicollapsed cinema-hall/ \apihandledby \syntaxcomplex{CinemaHallController}.
.3 \apiexpanded movie/ \apihandledby \syntaxcomplex{MovieController}.
.4 list \type \syntaxprimitive{GET} \apihandledby listMovies() \type \syntaxkeyword{GetMoviesResponse}.
.4 list-full \type \syntaxprimitive{GET} \apihandledby listDetailedMovies()\type \syntaxkeyword{GetMoviesFullResponse}.
.4 create \type \syntax[colorbrownish]{POST} \apihandledby createMovie(\syntaxkeyword{CreateMovieRequest})\type \syntaxkeyword{CreateMovieResponse}.
.4 update \type \syntax[colorbrownish]{POST} \apihandledby updateMovie(\syntaxkeyword{UpdateMovieRequest})\type \syntaxkeyword{UpdateMovieResponse}.
.4 delete \type \syntax[colorbrownish]{POST} \apihandledby deleteMovie(\syntaxkeyword{DeleteMovieRequest})\type \syntaxkeyword{DeleteMovieResponse}.
.3 \apicollapsed movie-screening/ \apihandledby \syntaxcomplex{MovieScreeningController}.
.3 \apicollapsed seat/ \apihandledby \syntaxcomplex{SeatController}.
.3 \apicollapsed seat-row/ \apihandledby \syntaxcomplex{SeatRowController}.
.2 \apiexpanded user/.
.3 \apicollapsed account/ \apihandledby \syntaxcomplex{UserAccountController}.
.3 \apicollapsed booking/ \apihandledby \syntaxcomplex{UserBookingController}.
.2 \apiexpanded admin/.
.3 \apicollapsed revenue/ \apihandledby \syntaxcomplex{AdminController}.
}
}
\renewcommand*\DTbaselineskip{20pt}
\raggedleft
{\scriptsize\vspace{-1cm}
\begin{tabular}{r@{ $\equalhat$ }l r@{ $\equalhat$ }l}
    \apicollapsed & \enquote{group collapsed} & \apiexpanded & \enquote{group expanded}\\
    \type & \enquote{is of type} & \apihandledby & \enquote{is handled by}\\
    \syntax[colorprimitive]{GET} & \enquote{\glsshort{a:http} GET request} & \syntax[colorbrownish]{POST} & \enquote{\glsshort{a:http} POST request}
\end{tabular}
\vspace{.25cm}}
\caption{Excerpt of the \gls{a:api} tree structure.}
\label{fig:api-tree}
\end{figure}

\Cref{fig:api-tree} presents an overview of all \gls{a:api} controllers and specifically of the endpoints within the \inlinecode{/management/movie} group. The \gls{a:api} endpoints are initially divided into three logical groups: \inlinecode{management}, \inlinecode{user}, and \inlinecode{admin}, each representing a different role. These logical groupings correspond to the Java packages containing the \gls{g:spring} controllers. On the second level, the endpoints are organized by their target, such as \inlinecode{movie} or \inlinecode{cinema-hall} for the management group. This second level maps to the respective Java \gls{g:spring} controller. Lastly, on the third level, endpoints are defined to handle the corresponding action, such as \inlinecode{list} or \inlinecode{create} for the movie controller. These endpoints map to the equivalent Java \gls{g:spring} controller methods.

Depending on the parameters necessary for executing the request action, either \inlinecode{GET} or \inlinecode{POST} requests are utilized. This is attributed to the fact that only \inlinecode{POST} requests can accommodate a body containing a \gls{a:json}-serialized request model. Consequently, communication through the \gls{a:api} is consistently \gls{a:json}-based. This approach simplifies the communication process, as both the client and server can effortlessly serialize and deserialize \gls{a:json} data, provided the \glspl{a:rrm} correspond. Additionally, \gls{a:json} is a prevalent choice for \gls{a:rest} \glspl{a:api} due to its lightweight nature, human readability, and compatibility with most programming languages, ensuring technology independence.

Java \gls{g:spring} controllers are tasked with converting \gls{a:json} request data into their respective Java request models and transforming Java response models into \gls{a:json} response data. To avert tight coupling and unintended cross-dependencies, each \gls{a:rrm} is exclusively employed by a single \gls{a:api} endpoint, facilitating model modification without the need for considering other endpoints. This encapsulation is illustrated in the simplified class diagram presented in \cref{fig:api-controllers}.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/api-controllers}
\caption{Simplified \gls{a:api} controller structure with encapsulated \glspl{a:rrm}.}
\label{fig:api-controllers}
\end{figure}

However, the \gls{a:json}-based communication method presents a limitation, as it hinders the reusability of the existing \gls{a:mps} data model. This can be attributed to the fact that the generated classes can not easily be converted to \gls{a:json}, due to the reliance on the supervisor pattern. As a result, \glspl{a:rrm} are manually created and maintained separately. Future research could explore the potential for automatically generating \glspl{a:rrm} from the \gls{a:mps} data model. This approach would reduce manual maintenance efforts and enable the client to use the same data model as the server, thereby decreasing the likelihood of \gls{a:api} mismatches.

\subsubsection{API Controllers}\label{sec:cs-api-controllers}

The \gls{a:api} controllers, as depicted in \cref{fig:api-controllers}, are implemented as Java \gls{g:spring} controllers. Each controller is responsible for processing requests and producing responses, with every \gls{a:api} endpoint mapped to a single Java method within a controller.

To adhere to \cref{req:isolation}, a \inlinecode{BaseController} class is developed to streamline interactions with the isolation service, discussed in further detail in \vref{sec:cs-isolation}. This class offers the \inlinecode{isolated()} method, which simplifies the execution of a lambda function within the context of the isolation service. By carrying out the entire endpoint handling process within the isolation service, potential interleaving of database access by concurrent requests is avoided. Each \gls{a:api} controller extends the \inlinecode{BaseController} class, making the \inlinecode{isolated()} method accessible to all controllers. This approach reduces the complexity of the \gls{a:api} controllers, as the actual \gls{a:api} endpoint handling code does not need to address the isolation service directly. An illustrative example of employing the \inlinecode{BaseController} class is presented in \cref{lst:api-controllers-basecontroller}.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize,linenos]{java}
@RestController
@RequestMapping(path="/api/foo", produces="application/json")
@CrossOrigin(origins="*")
public class FooController extends BaseController {
    @GetMapping("/bar")
    public ResponseEntity<BarResponse> getTheBar() {
        return isolated(() -> {
            // run business logic in isolated context...
            BarResponse response = ...
            return new ResponseEntity<BarResponse>(response, HttpStatus.OK);
        });
    }
}
\end{minted}
\caption{Utilization of the \inlinecode{isolated()} method in a concrete \gls{a:api} controller.}
\label{lst:api-controllers-basecontroller}
\end{listing}

\Cref{lst:api-controllers-basecontroller} demonstrates the use of the \inlinecode{isolated()} method within a concrete \gls{a:api} controller. As shown in line 7, the \inlinecode{isolated()} method accepts the request handling logic as a lambda function, which is executed in the context of the isolation service. The lambda function must return a \inlinecode{ResponseEntity} object containing the response data and the \gls{a:http} status code, which is then returned by the \inlinecode{isolated()} method. If an exception arises during the lambda function's execution, the isolation service automatically catches it and converts it into an error response with a suitable \gls{a:http} status code and stack trace information.

As illustrated in \cref{lst:api-controllers-basecontroller}, \gls{g:spring} mandates that the \inlinecode{ResponseEntity} be returned by the same controller method responsible for handling the request. This implies the execution within the isolation context to be, or appear to be, synchronous from an external perspective, as the controller method cannot return before the lambda function's execution is complete. This critical constraint must be taken into account when designing the isolation service, as asynchronous execution is not feasible. Consequently, this new requirement is formalized as \requirementdef\label{req:synchronous-isolation}.

\subsection{Isolation Service}\label{sec:cs-isolation}

As discussed in \cref{sec:cs-data-model}, the \gls{a:mps} framework is used to transform the data model into the required Java source code for the data access layer, concurrently generating a compatible database schema in MySQL to facilitate seamless database migrations. However, at the time of writing, the generated data access layer lacks isolation capabilities, rendering it incapable of handling transactional operations.

To enable concurrent data access from multiple clients, the server implements a custom isolation service atop the generated data access layer. This service is tasked with serializing concurrent accesses into a sequential chain of operations. Database operations are scheduled on a dispatch collection and executed by a self-balancing, bounded thread pool that supports various scheduling policies. The term \enquote{self-balancing} denotes that the quantity of worker threads varies depending on the load, while \enquote{bounded} refers to the ability to define an upper limit for concurrently active worker threads. A basic \gls{a:fifo} scheduling policy was selected for this application to prevent starvation and ensure fairness. Future enhancements could involve upgrading the basic \gls{a:fifo} queue to a priority heap structure, permitting more thorough control over scheduling, such as prioritizing management or administrative operations over user operations.

Although the thread pool theoretically maintains a flexible number of worker threads, adjusting dynamically based on the load, the maximum number of worker threads is practically limited to one to preserve the sequential execution of operations. Consequently, the thread pool effectively operates as a single-threaded queue. Nevertheless, the overall design could accommodate parallel execution of database operations in the future if the data model were expanded to support it.

To ensure compatibility with the \gls{g:spring} \gls{a:api} controllers, the isolation service must operate synchronously, as \gls{g:spring} anticipates that the thread handling a request will also be accountable for sending the response back to the client. This compatibility concern was identified in \cref{sec:cs-api} and subsequently incorporated as \cref{req:synchronous-isolation} for the isolation layer.

\pagebreak

\subsubsection{Workload Management}

As depicted in \cref{fig:workload-overview}, the isolation service (\inlinecode{IsolationService}) serves as an entry-point  for the highly configurable \inlinecode{WorkloadManager} class. While the \inlinecode{WorkloadManager} is responsible for maintaining the dispatch queue and worker thread pool, the \inlinecode{IsolationService} merely introduces an additional layer of abstraction, serving as a facade to encapsulate the intricacies of workload management. As such, a singular \inlinecode{schedule()} method is exposed, mapping a provided lambda expression to a workload object, which the caller can use to block until the operation is completed and to retrieve the results. This approach facilitates seamless integration with the \gls{g:spring} \gls{a:api} controllers, as no callbacks are necessary. The following paragraphs aim to offer a more comprehensive description of this execution process.

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{images/workload-management.pdf}
\caption{Simplified class diagram of the isolation service}
\label{fig:workload-overview}
\end{figure}

When scheduling an operation of type \inlinecode{Supplier<TResult>}, the \inlinecode{IsolationService} instantiates a new \inlinecode{AsyncWorkload<TResult>} object, which is then placed onto the dispatch queue. Subsequently, it returns the workload object to the caller, who can then obtain the \inlinecode{CompletableFuture<IAsyncResult<TResult>>} object from the workload object and utilize it to block until the operation is completed and to retrieve the results.

Simultaneously, scheduling the workload induces the \inlinecode{WorkloadManager} to attempt to adjust the number of active workers. Initially, a synchronization lock is acquired to guarantee that the active worker count remains consistent while subsequent steps are performed. The \inlinecode{WorkloadManager} then checks if the maximum worker count has been reached; if not, the number of active workers is incremented by one, and a new worker thread is created. The caller releases the synchronization context and the new worker thread tries to dequeue workloads from the dispatch queue for execution. This process begins by acquiring another synchronization lock specific to the dispatch queue. Following this, another check is initiated to verify and adjust the worker counts, assuring that the new worker thread is still required and that the number of allowed threads was not altered since the last check.

If the upper boundary of threads has been violated, the worker thread terminates and another existing thread handles execution of the scheduled workload. Otherwise if the upper limit has not yet been reached and more workloads are available, an additional worker thread is created. In any case other than termination, the worker thread attempts to dequeue a workload from the dispatch queue. If the dispatch queue is empty, the thread decrements the active worker count by one, and terminates. Otherwise, the worker thread assesses whether the workload was canceled while waiting in the dispatch queue; if so, it retrieves the next workload from the queue. In any other ways, the workload is set to \inlinecode{SchedulingStatus.Executing}, forestalling attempts to cancel it, and the worker thread carries on with workload execution, invoking the provided lambda expression and storing the result by completing the corresponding \inlinecode{Future}  object in the \inlinecode{AsyncWorkload}. If an exception is raised in client code during execution, the Future is completed with the exception object. Finally, this process is repeated until the dispatch queue is empty, and the number of active workers is reduced to zero.

Once the \inlinecode{Future} object is completed, the calling \gls{a:api} controller thread unblocks, and a response is transmitted back to the client.

\pagebreak

\section{Client}
\label{sec:cs-client}

This section presents the client application, which is the interface through which the user interacts with the system. The client application conforms to \cref{req:client-portability} (portability) by utilizing the most recent C\# 11/.NET 7 \gls{a:sdk}. C\# was chosen over Java, primarily due to a reduction of boilerplate code and greater portability, as the application can be published with a self-contained trimmed \gls{a:cclr}, eliminating the dependency on a separate .NET runtime installation. Additionally, the authors are more familiar with C\#, making it a natural choice.

\subsection{Introduction}

Despite being designed as a command line interface without a graphical user interface, it strives to maintain an intuitive and user-friendly experience, enabling users to efficiently manage the cinema system on a day-to-day basis. Cinema employees utilize the application for creating, modifying, and deleting movies, cinema halls, seat rows, seats, and showtimes, while customers use it for booking and canceling tickets. Additionally, the client application supports administrative tasks, such as analyzing movie and showtime revenue. Consequently, the client application must differentiate between three use-case sets: \inlinecode{management}, \inlinecode{user}, and \inlinecode{administration} (abbreviated as \inlinecode{admin}).

To prioritize accessibility, commands are designed for intuitive and natural interaction. The first command layer corresponds to use-case groups, while the second layer denotes specific operations (\gls{a:crud}). Common aliases are provided for each command, allowing users to select their preferred syntax. Each command specifies a target for the operation, resulting in a three-part structure: the use-case group, specific operation, and target. For instance, \inlinecode{management create movie} and \inlinecode{user create booking} are valid commands. A \inlinecode{help} command facilitates \gls{a:cli} navigation, displaying available commands and options depending on the user's position within the command tree. For example, \inlinecode{management help} lists all available management commands, while \inlinecode{management create help} enumerates valid targets for the create command in the management context.

The subsequent sections delve into the components required for implementing these features. \Cref{sec:cs-cli} examines the \gls{a:cli} parser, \cref{sec:cs-api-access} discusses the infrastructure necessary for server access, and \cref{sec:cs-autocomplete} introduces the autocomplete layer.

\subsection{Command line parsing}\label{sec:cs-cli}

%System.CommandLine framework and command processing

A primary concern for the client involves developing an intuitive command line interface. To tackle this issue, the \inlinecode{System.CommandLine} framework is employed for parsing \gls{a:cli} commands and arguments. Consequently, a hierarchical command-argument structure is established to facilitate the interpretation of user input. The syntax tree depicted in \cref{fig:command-tree} illustrates the command structure available to the client. It is essential to note that the root node functions solely as a logical container for the main commands.
\begin{minipage}[t]{0.45\textwidth}
The child nodes of the root node comprise management, user, and admin commands, which align with the distinct use-case groups identified in \cref{sec:use-cases}. Management sub-commands are generalized into the \inlinecode{ManagementCommand} class, which defines common management target arguments, represented as enums, employed by the concrete \gls{a:crud} commands that extend the \inlinecode{ManagementCommand} class.

The user sub-tree is similarly divided into create, read, update, and delete commands. However, these sub-commands are not consolidated into a single class, as they may not share identical arguments. For example, customers can create ticket reservations and bookings, but only ticket reservations may be cancelled. An optional \inlinecode{--as-identity} option may be utilized to specify the user or customer identity for performing the designated action. If no identity is specified, the user% don't touch this lol
\end{minipage}
\hfill
\begin{minipage}[t]{0.6\textwidth}
\vspace{-.5cm}
\begin{figure}[H]
\renewcommand*\DTbaselineskip{10pt}
{\scriptsize
\dirtree{%
.1 root \type \syntaxcomplex{RootCommand}.
.2 management \extends \syntaxcomplex{Command}.
.3 \syntaxcomplex{ManagementCommand} \syntaxkeyword{<<abstract>>} \extends \syntaxcomplex{Command}.
.4 movies \type \syntaxprimitive{ManagementOperationTarget}.
.4 screenings \type \syntaxprimitive{ManagementOperationTarget}.
.4 halls \type \syntaxprimitive{ManagementOperationTarget}.
.4 rows \type \syntaxprimitive{ManagementOperationTarget}.
.4 seats \type \syntaxprimitive{ManagementOperationTarget}.
.3 create \extends \syntaxcomplex{ManagementCommand}.
.3 read \extends \syntaxcomplex{ManagementCommand}.
.3 update \extends \syntaxcomplex{ManagementCommand}.
.3 delete \extends \syntaxcomplex{ManagementCommand}.
.2 user \extends \syntaxcomplex{Command}.
.3 {-}-as-identity \type \syntaxcomplex{Option}.
.4 identity \type \syntaxprimitive{string}.
.3 create \extends \syntaxcomplex{Command}.
.4 user \type \syntaxprimitive{UserCreateCommandTarget}.
.4 booking \type \syntaxprimitive{UserCreateCommandTarget}.
.4 reservation \type \syntaxprimitive{UserCreateCommandTarget}.
.3 read \extends \syntaxcomplex{Command}.
.4 users \type \syntaxprimitive{UserReadCommandTarget}.
.4 bookings \type \syntaxprimitive{UserReadCommandTarget}.
.4 reservations \type \syntaxprimitive{UserReadCommandTarget}.
.3 update \extends \syntaxcomplex{Command}.
.4 reservation \type \syntaxprimitive{UserUpdateCommandTarget}.
.3 delete \extends \syntaxcomplex{Command}.
.4 user \type \syntaxprimitive{UserDeleteCommandTarget}.
.4 reservation \type \syntaxprimitive{UserDeleteCommandTarget}.
.3 book \syntaxkeyword{<<alias>>} \extends \syntaxcomplex{Command} $\implies$ create booking.
.3 reserve \syntaxkeyword{<<alias>>} \extends \syntaxcomplex{Command} $\implies$ create reservation.
.3 cancel \syntaxkeyword{<<alias>>} \extends \syntaxcomplex{Command} $\implies$ delete reservation.
.2 admin \extends \syntaxcomplex{Command}.
.3 show \extends \syntaxcomplex{Command}.
.4 revenue \type \syntaxprimitive{AdminReadCommandTarget}.
}
}
\renewcommand*\DTbaselineskip{20pt}
\caption{The client command syntax tree.}
\label{fig:command-tree}
\end{figure}
\end{minipage}
\vspace{-.25cm}

will be prompted to enter their respective email address in a subsequent step. Finally, a collection of alias commands are incorporated into the user command, which directly correspond to their respective \gls{a:crud} commands.

The admin sub-tree shares similarities with the user sub-tree but consists solely of the read command, employed to display the revenue of a specified movie or movie screening.

\subsubsection{Class Design}

To implement \gls{a:cli} commands in a structured and maintainable fashion, the \inlinecode{System.CommandLine} framework is encapsulated within a class hierarchy, as illustrated in \vref{fig:command-classes}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/client-cli-command-parsing.pdf}
    \caption{Class hierarchy of the \gls{a:cli} command parsing framework.}
    \label{fig:command-classes}
\end{figure}

\Cref{fig:command-classes} displays the fundamental classes and interfaces of the command tree, along with an exemplary implementation of the \inlinecode{admin show} command.

The class hierarchy can be divided into command builders and command handler classes. Command builders serve to define and configure \inlinecode{System.CommandLine} command objects and their respective arguments. Command handler classes are responsible for configuring sub-commands on the \inlinecode{System.CommandLine} command objects within their corresponding \inlinecode{RegisterOn} methods and managing command execution through their \inlinecode{Handle} methods.

The configuration workflow generally adheres to the following steps:

\begin{enumerate}
    \item A command builder is instantiated and configured with the required arguments.
    \item The \inlinecode{builder.Build()} method is called to create and configure the \inlinecode{System.CommandLine} command object.
    \item The command object is added to the parent or root command object.
    \item The newly created command object is passed to the \inlinecode{RegisterHandler} method in the abstract \inlinecode{CommandBuilderBase} class, which subsequently generates the respective command handler using the static abstract \inlinecode{Create} factory method on the \inlinecode{THandler} type parameter.
    \item The \inlinecode{RegisterHandler} method calls the \inlinecode{RegisterOn} method on the command handler instance, which is accountable for registering sub-commands on the \inlinecode{System.CommandLine} command object. This is accomplished by instantiating one or more new command builders and passing them an instance of their corresponding parent, restarting from step 1.
\end{enumerate}

Consequently, each node in the syntax tree presented in \cref{fig:command-tree} is represented by an implementation of the \inlinecode{ICommandBuilder} interface, which in turn possesses a corresponding handler to recursively configure child command builder nodes. This arrangement offers a coherent and maintainable structure for the command tree, which can be effortlessly extended by incorporating new command builders and handlers for additional commands and their respective sub-commands.

A challenge presented by this command tree design involves the necessity to propagate global options, such as the \inlinecode{--as-identity} option in the user command sub-tree, from parent nodes to their child nodes. This is essential since the sole approach of obtaining the values of global options in the Handle methods of leaf nodes is via the original \inlinecode{System.CommandLine} option instance, configured by the parent command builder. As a result, any such options are stored within the respective command builder, which can then be injected into the corresponding command handler and passed down to subsequent layers of the command tree. To facilitate this process, C\# 11's support for static abstract interface members is employed. This enables the \inlinecode{Create} factory method to be defined and invoked using the associated generic type parameter \inlinecode{THandler}, mitigating the need for a separate factory object, or for explicit casts on the callee side if a generic factory is used. This design pattern is demonstrated in \cref{lst:command-builder-static-abstract-interface-members}.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize,linenos,mathescape]{csharp}
public interface ICliHandler<TBuilder, THandler> : ICliHandler<TBuilder>
    where TBuilder : ICommandBuilder 
    where THandler : class, ICliHandler<TBuilder, THandler> 
{
    ...
    static abstract THandler Create(TBuilder builder); // static abstract factory method$\label{lst:ln:THandler-definition}$
}

public abstract class CommandBuilderBase<TBuilder, THandler> : CommandBuilderBase
    where TBuilder : CommandBuilderBase<TBuilder, THandler>
    where THandler : class, ICliHandler<TBuilder, THandler>
{
    ...
    // the generic RegisterHandler implementation
    protected static Command RegisterHandler(TBuilder builder, Command command)
    {
        // invocation of static method on the THandler type parameter which is known to 
        // implement the corresponding ICliHandler interface
        THandler handler = THandler.Create(builder); // use static interface method$\label{lst:ln:THandler-usage}$
        handler.RegisterOn(command);
        return command;
    }
}
\end{minted}
\caption{Utilization of a static abstract factory interface in the generic \inlinecode{RegisterHandler} implementation.}
\label{lst:command-builder-static-abstract-interface-members}
\end{listing}

\Vref{lst:command-builder-static-abstract-interface-members} presents the definition of the static abstract factory method in \inlinecode{ICliHandler} in \lref{lst:ln:THandler-definition} and its usage in the generic implementation of the \inlinecode{RegisterHandler} method in \lref{lst:ln:THandler-usage}. Generic constraints on the type parameters of \inlinecode{CommandBuilderBase} and \inlinecode{ICliHandler} ensure the appropriate command handler is created and registered for the corresponding command builder, eliminating the need for explicit casts or type checking.

\subsection{API Access}\label{sec:cs-api-access}

Upon command execution, the corresponding command handler class assumes responsibility for managing the command's execution.

Since the majority of leaf nodes in the command tree correspond to enums, the respective enum value is passed to the command handler, which subsequently switches on its value and invokes the appropriate \inlinecode{RemoteOperation} delegate. The \inlinecode{RemoteOperation} delegate refers to a method in the associated \inlinecode{Operation} class, which is specific to the handler and is accountable for performing one or more \gls{a:api} calls relevant to the requested operation. This approach enables command handler classes to remain independent of the actual \gls{a:api} calls, concentrating solely on managing the command's execution and promoting a cleaner separation of concerns. The hierarchy of user operation classes depicted in \cref{fig:client-operations} serves as a representative example for other operation class hierarchies.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/client-operations}
    \caption{User operation class hierarchy.}
    \label{fig:client-operations}
\end{figure}


As illustrated in \cref{fig:client-operations} the \inlinecode{OperationBase} class maintains a reference to an \inlinecode{ApiContext} object, responsible for storing the \inlinecode{HttpClient} instance utilized for all \gls{a:api} calls, as well as the server's base \gls{a:uri}. This ensures that each operation uses the same \inlinecode{HttpClient} instance and thus, the same connection pool, which is crucial for performance considerations. Upon creation of an operation object, it receives a reference to the \inlinecode{ApiContext} object, which is subsequently stored in the corresponding property. Additionally, every operation class has a \inlinecode{Uri} property, initialized in the constructor, that represents the relative path from the server's base \gls{a:uri} to the corresponding \gls{a:api} controller that manages the requested operation.

When an operation is executed by the command handler, the \inlinecode{Uri} property is queried to construct the absolute \gls{a:uri} of the desired \gls{a:api} controller. Depending on the operation, one or more \gls{a:api} calls are performed to aggregate data necessary for user interaction, displaying results, or executing the requested operation. Once the operation is complete, the client application terminates.

\subsection{Autocomplete Wrapper}\label{sec:cs-autocomplete}

Given that the client itself is a command line application with the capacity to execute only one command at a time, an additional wrapper application has been implemented to provide dynamic autocompletion and syntax highlighting based on the command syntax tree defined in the client. As this wrapper is also developed in C\#, it can import the client executable as a dependency, enabling the generation of a syntax tree of autocompletion node data based on the command tree defined in the client. This facilitates seamless integration of the client application into the shell environment. The wrapper application also maintains an additional command history stack, allowing for quick navigation through previously executed commands. The architecture of the wrapper application is depicted in \cref{fig:client-wrapper}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/client-wrapper}
    \caption{Architecture of the client wrapper application.}
    \label{fig:client-wrapper}
\end{figure}

As shown in Figure \ref{fig:client-wrapper}, the core class of the wrapper is the \inlinecode{Shell} class, which is responsible for monitoring key presses, managing dependent classes, and slaving the client application to the current command line.

When the \inlinecode{Shell::Start()} method is invoked, a prompt is rendered to the screen using the \inlinecode{LineRenderer} class, which also offers support for parsing \gls{a:ansi} color codes. As soon as a key press event is raised, the following parsing algorithm is executed:

\begin{enumerate}
    \item The key information is read, and depending on the character, one of these actions is taken:
    \begin {enumerate}
        \item For alphanumeric \gls{a:ascii} characters or symbols, the character is appended to the \inlinecode{ArgumentBuilder} and \inlinecode{LineRenderer}. The \inlinecode{ArgumentBuilder} updates its internal \inlinecode{WordBuilder} instance accordingly.
        \item For arrow keys (up or down), the previous or next command from the command history is retrieved using the \inlinecode{CinemaArgumentsHistory} class. The \inlinecode{ArgumentBuilder} and \inlinecode{LineRenderer} are updated, the prompt is redrawn, and the key parsing process \textbf{concludes} and is ready to handle the next key press.
        \item For a backspace key, the last character or word (depending on whether the control key is also pressed) is removed from the \inlinecode{ArgumentBuilder} and \inlinecode{LineRenderer}. The \inlinecode{ArgumentBuilder} updates its internal \inlinecode{WordBuilder} instance accordingly.
        \item For a space or enter key, the \inlinecode{ArgumentBuilder} flushes it's current word, validates the new argument against the syntax tree by invoking the \inlinecode{CommandCompletionService}, and pushes the argument onto the argument stack.
        \begin{enumerate}
            \item If the enter key is pressed, the renderer completes the current line, the \inlinecode{ArgumentBuilder} is flushed, and a new line is rendered. The client application is then spawned as a slave process, forwarding input, output, and error streams to the master. When the client process exits, the key parsing \textbf{concludes} and is ready to handle the next key press.
            \item Otherwise, if the key is a space, the space character is added to the renderer.
        \end{enumerate}
        \item Any other keys are ignored for now.
    \end{enumerate}
    \item The \inlinecode{ArgumentBuilder} validates its current argument stack and partial argument against the syntax tree.
    \begin{enumerate}
        \item If the argument is valid, it is passed to the \inlinecode{CommandCompletionService}, and the autocomplete cache is updated accordingly. The \inlinecode{CommandCompletionService} returns a list of possible completions for the current argument.
        \item Otherwise, the renderer is updated to re-render the current line in red for the next call to \inlinecode{RenderPrompt()}.
    \end{enumerate}
    \item One of the following actions is taken:
    \begin{enumerate}
        \item If the key is a tab key, the current partial input is backed up, and one of these actions is taken:
        \begin{enumerate}
            \item If the autocomplete cache is empty, the cache is updated by invoking the \inlinecode{CommandCompletionService} with the current argument.
            \item Otherwise, the autocomplete cache is queried for possible completions for the current argument.
            \begin{enumerate}
                \item If the previous key was also a tab key, the next completion in the autocomplete cache is returned.
                \item Otherwise, the first completion in the autocomplete cache is returned.
                \item If the autocomplete cache is empty or no next completion exists, the backup is restored.
            \end{enumerate}
            \item The \inlinecode{ArgumentBuilder} and \inlinecode{LineRenderer} are updated with the new completion.
        \end{enumerate}
        \item Otherwise, the autocomplete cache is reset.
    \end{enumerate}
    \item The current line is re-rendered.
    \item The key parsing concludes and is ready to handle the next key press.
\end{enumerate}

Overall, the shell wrapper aims to provide seamless integration of the client application into the shell environment, enabling a more intuitive user experience.

\chapter{Implementation}
\label{ch:impl}

\todo{this chapter is a draft!}

All proposed concepts have been implemented in a \gls{g:cms} prototype. This chapter presents key design decisions and implementation details, including necessary adjustments to the architecture, as well as lessons learned. Finally the prototype is verified against the requirements defined in \cref{sec:requirements}. 

\section{HTTP Response Model Mapping}\label{sec:impl-lombok}

One of the adjustments made to original architecture described in \vref{fig:architecture} was the addition of the lombok code generation library to be used to help with the implementation of the JSON Request/Response Model. Following the core principles of Model Driven Development, Lombok is a Java library that uses a more abstract representation of a Java class to automatically generate implementation-details such as getter and setter methods at compile time for fields. \Cref{fig:architecture-with-lombok} reflects the resulting changes to the project architecture.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/big-picture}
    \caption{The final project architecture after the addition of lombok.}
    \label{fig:architecture-with-lombok}
\end{figure}

For the prototype, the \inlinecode{@Data} annotation was used to generate getter and setter methods for each field. This annotation was used for all Request/Response Model classes in the \gls{g:cms} prototype, which reduced the amount of boilerplate code that needed to be written. This improvement in code maintainability was achieved with very little effort and proved to be a valuable time-saver, allowing the development team to focus more on the implementation of the actual functionality. The following example aims to illustrate the benefits of using lombok.

\begin{figure}[H]
\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
public class UserUpgradeReservationRequest {
    private Integer reservationId;
    private String email;
    public Integer getReservationId() {
        return this.reservationId;
    }
    public void setReservationId(Integer value) {
        this.reservationId = value;
    }
    public String getEmail() {
        return this.email;
    }
    public void setEmail(String value) {
        this.email = value;
    }
}
...
String email = request.getEmail(); // works
\end{minted}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\scriptsize,linenos]{java}
@Data
public class UserUpgradeReservationRequest {
    Integer reservationId;
    String email;
}
...
String email = request.getEmail(); // works
\end{minted}
\end{minipage}
\captionof{listing}{The same class before and after applying the \inlinecode{Data} annotation}
\label{lst:lombok-example}
\end{figure}

\cref{lst:lombok-example} shows the same \inlinecode{UserUpgradeReservationRequest} class before and after applying the \inlinecode{Data} annotation. The \inlinecode{Data} annotation generates getter and setter methods for each field, which are then used in the same way as in the original, hand-written class. The code in the \inlinecode{UserUpgradeReservationRequest} class is reduced from 23 lines to 5 lines, which corresponds to a 78\% reduction in boilerplate code. This reduction in boilerplate code results in a large improvement in maintainability of the project, as less code needs to be written and maintained. 

\section{Reflective Object Mapping}\label{sec:impl-reflective-object-mapping}

Another optimization made to the Request/Response Model implementation was the addition of the \inlinecode{ObjectX} (Object Extensions) class to the project. \inlinecode{ObjectX} provides a set of reflection-based methods used to create a response object from a given \gls{a:mps}-generated data model instance, based on a given response class. The \inlinecode{ObjectX} class then uses reflection to enumerate shared properties with matching names and datatypes between the data model instance and the response class. Then a new instance of the response class is created and values are copied from the data model instance to the response class instance. \Cref{fig:reflective-object-mapping} illustrates the concept of this process.

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{java}
@GetMapping("/list")
public ResponseEntity<GetMoviesResponse> listMovies() 
{
    return isolated(() -> 
    {
        GetMoviesResponse response = new GetMoviesResponse();
        response.setMovies(ObjectX.createFromMany(
            CinemaService.getInstance().getMovieCache().values(), 
            GetMoviesResponseEntry.class));
        response.setSuccess(true);
        return new ResponseEntity<GetMoviesResponse>(response, HttpStatus.OK);
    });
}
\end{minted}
\caption{Example of a controller method using the \inlinecode{ObjectX} class to efficiently transform a data model instance to a response model instance.}
\label{lst:reflective-object-mapping-example}
\end{listing}

\Cref{lst:reflective-object-mapping-example} shows an example of the \inlinecode{MovieController} class using the \inlinecode{ObjectX} class to efficiently transform a set of \inlinecode{Movie} instances to a set of \inlinecode{GetMoviesResponseEntry} response model instances.

In combination with the lombok-annotated response model classes, the work overhead of using JSON Request/Response Models is reduced to a minimum, resulting in a significant improvement of development speed.

\section{Challenges and limitations}\label{sec:impl-challenges}

During development of the prototype, a number of challenges were encountered, some of which are discussed in this section.

\subsection{Inserting Default Values for PriceCategories}

As per the data model defined in \cref{sec:cs-data-model}, the \inlinecode{PriceCategory} class has a \inlinecode{price} attribute. In the design, this attribute was intended to be of type \inlinecode{Rational}, with pre-defined values corresponding to the price of a ticket for a \inlinecode{PriceCategory}. As these default values are not part of the data model, the \inlinecode{price} attribute must be initialized with a value before being used in the application. The idea was to eagerly initialize the \inlinecode{price} as soon as the server application starts up. In order to achieve this, the guard clause shown in \cref{lst:price-category-initialization} was added to the main method of the \gls{g:cms}:

\begin{listing}[H]
\begin{minted}[fontsize=\scriptsize]{java}
@SpringBootApplication
public class Program 
{
	public static void main(String[] args) 
    {
		if (!PriceCategoryStalls.getInstance().getPrice().isPresent())
		{
			PriceCategoryStalls.getInstance().setPrice(new Rational(10));
			PriceCategoryBox.getInstance().setPrice(new Rational(12));
			PriceCategoryServiceBox.getInstance().setPrice(new Rational(16));
		}
		SpringApplication.run(Program.class, args);
	}
}
\end{minted}
\caption{Guard clause for initializing default values of price categories.}
\label{lst:price-category-initialization}
\end{listing}

As shown in \cref{lst:price-category-initialization}, the \inlinecode{PriceCategory} instances are initialized with default values if they are not already set. Interestingly enough, this attempt to initialize default values did not work as expected. The \inlinecode{PriceCategoryBox} and \inlinecode{PriceCategoryServiceBox} were initialzed correctly, but the \inlinecode{PriceCategoryStalls} instance was not. Further testing revealed that whatever price category was initialized first, would never succeed in setting a price and that even subsequent attempts to initialize the corresponding price category would fail. Other price categories could always be initialized successfully, but the first price category would always fail. Due to time constraints, this issue could not be investigated further when the prototype was developed, resulting in the price attribute being temporarily removed from the data model, and offline price calculations based on the type of the \inlinecode{PriceCategory} instance being implemented. 

Future work should investigate this issue in more detail to determine the root cause and to determine whether this a bug orginated in the \gls{a:mps} or in the \gls{g:cms}.

\subsection{Inconsistent database states and the lack of transactions}

One of the main hinderences to the development of the prototype was the lack of database transactions being generated by \gls{a:mps}. While concurrency issues could be resolved using the isolation service described in \cref{sec:cs-isolation}, the lack of transactions resulted in the data access layer being unable to rollback changes made to the database in case of an error. This issue manifested itself in the server application crashing randomly during subsequent data access operations and was a major source of frustration during development. As such, until sources of these errors could be identified and resolved during the implementation of cascading deletions, it was common practice to drop the database and re-run the \gls{a:mps} generator every time the server was restarted during development. This resulted in a significant increase in development time, as test data had to be re-entered every time the server was restarted.

Future work to extend the \gls{a:mps} generator to create correct transactional data access code should commence before the prototype is deployed to any production environment.